
var Stream = require('stream').Stream;
var util = require('util');

var utils = new(function() {

  this.concat = function(chunks, len) {
    var buf = new Buffer(len), offset = 0;

    for (var i=0, _len=chunks.length;i<_len;i++) {
      var chunk = chunks[i];
      var cLen = chunk.length;
      chunk.copy(buf, offset, 0, cLen);
      offset += cLen;
    };

    return buf;
  };

  this.isBuffer = function(buf) {
    return buf instanceof Buffer;
  };

});

function Suckle() {
  Stream.call(this)

  this.writable = true;
  this.fns = [];
  this.chunks = [];
  this.len = 0;

  var pipes
  = this.pipes
  = Array.prototype.slice.call(arguments);

  var lastArg = pipes[pipes.length-1];
  if (typeof(lastArg) === 'function') {
    this.fns.push(pipes.pop());
  };
}

util.inherits(Suckle, Stream);

Suckle.prototype.oncomplete = function(fn) {
  this.fns.push(fn);
};

Suckle.prototype.pipe = function(dest) {
  this.pipes.push(dest);
  return dest;
};

Suckle.prototype.invokeCallbacks = function() {
  var bLen = this.len;
  var buf = utils.concat(this.chunks, bLen);

  var fns = this.fns;
  var len = fns.length;
  for (var i=0; i<len; i++) {
    fns[i](buf, bLen);
  };
};

Suckle.prototype.appendData = function(data, encoding) {
  if (!this.fns.length) return;
  
  var buf = utils.isBuffer(data) ? data 
    : new Buffer(data, encoding);

  this.chunks.push(buf);
  this.len += buf.length;
};

Suckle.prototype.write = function(data, encoding) {
  var pipes = this.pipes;
  var len = pipes.length;

  for (var i=0; i<len; i++) {
    pipes[i].write(data, encoding);
  };

  this.appendData(data, encoding);
};

Suckle.prototype.end = function() {
  var pipes = this.pipes;

  for (var i=0, len=pipes.length; i<len; i++) {
    pipes[i].end();
  };

  this.invokeCallbacks();
};

module.exports = Suckle;
