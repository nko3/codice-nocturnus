
var fs      = require('fs');
var Suckle  = require('suckle');
var support = require('./support');
var spawn   = require('child_process').spawn;

exports.Minifier = Minifier;

exports.minify = function() {
  var args = Array.prototype.slice.call(arguments);
  var options = {}, fn;
  var firstArg = args[0];
  var lastArg = args[args.length-1];

  fn = typeof lastArg === 'function' 
  && args.pop();

  switch (firstArg.constructor) {
    case Object:
      options = args.shift();
      options.fileOut = options.fileOut 
      || args.shift();
      break;
    case Array:
    case String:
      var fileIn = args.shift();
      var nextArg = args.shift();
      var type = typeof nextArg;
      if (type === 'object') {
        options = nextArg;
      } else if (type === 'string') {
        options.fileOut = nextArg;
      };
      options.fileIn = fileIn;
      break;
    case fs.ReadStream:
      firstArg = args.shift();
      firstArg.pause();

      var nextArg = args.shift();
      var type = typeof nextArg;

      if (type === 'object') {
        options = nextArg;
      } else if (type === 'string') {
        options.fileOut = nextArg;
      };

      options.stream = firstArg;
      break;
  };

  var minifier = new Minifier(options);
  return minifier.compress(fn);
};

exports.createMinifyStream = function(stream, options, fn) {
  var args = Array.prototype.slice.call(arguments);
  var stream = args.shift();
  stream.pause();

  var lastArg = args[args.length-1];
  fn = typeof lastArg === 'function' 
  && args.pop();

  var options = args.shift() || {};
  options.stream = stream;

  var minifier = new Minifier(options);
  return minifier.compress(fn);
};

function Minifier(options) {
  var fileIn = options.fileIn || null;

  if (Array.isArray(fileIn)) {
    var fileType = support.fileType(fileIn[0]);
    function sameType(type) {
      return type === fileType;
    };

    var uniform = fileIn
    .map(support.fileType)
    .every(sameType);

    if (!uniform) {
      throw new Error('Non-uniform filetypes');
    } else {
      this.fileType = fileType;
    };

    this.fileIn = fileIn;
  } else if (typeof fileIn === 'string') {
    this.fileIn =  [fileIn];
    this.fileType = support.fileType(fileIn);
  } else {
    this.fileType = 'css';
  };

  var css = /^css$/.test(this.fileType);
  this.bufferSize = options.bufferSize || 64 * 1024;
  this.type   = options.type || (css ? 'yui' : 'uglify');
  this.encoding = options.encoding;
  this.fileOut = options.fileOut;
  this.stream   = options.stream;
};

Minifier.prototype.compress = function(fn) {
  var func = typeof fn === 'function' ? fn : new Function;
  var props = [ this.options, this.fileType ];
  var command = support[this.type].apply(this, props);
  var error = null;
  var errData = '';
  var enc = this.encoding;

  var cb = function(data) {
    if (errData) {
      error = new Error(errData);
    } else if (enc) {
      data = data.toString(enc);
    };
    func(error, data);
  }.bind(this); 

  var suckle = new Suckle(cb);

  if (typeof this.fileOut === 'string') {
    var ws = fs.createWriteStream(this.fileOut);
    suckle.pipe(ws);
  };

  var args = command.args;
  var command = command.command;
  var opts = { maxBuffer:this.bufferSize, stdio:'pipe' };
  var _compress = spawn(command, args, opts);

  function erred(err) {
    error = err;
    _compress.kill();
  };

  _compress.on('error', erred);

  _compress.stderr.setEncoding('utf8');
  _compress.stderr.on('data', function(d) {
    errData += d;
  });

  _compress.stdout.setEncoding('utf8');
  _compress.stdout.pipe(suckle);

  var stdin = _compress.stdin;
  var write = stdin.write.bind(stdin);
  var end   = stdin.end.bind(stdin);

  if (this.stream) {
    this.stream.pipe(_compress.stdin);
    this.stream.resume();
  } else if (this.fileIn) {
    var fileIn = this.fileIn.slice();
    var _nt = process.nextTick;

    function next() {
      if (!fileIn.length) return end();

      var file = fileIn.shift();
      var _next = _nt.bind(this, next);

      if (typeof file === 'string') {
        var rs = fs.createReadStream(file);
        rs.on('data', write);
        rs.on('error', erred);
        rs.on('end', _next);
      } else {
        _next();
      };
    };

    next.call(this);
  };

  return _compress.stdout;
};
